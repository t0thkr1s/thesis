\documentclass{thesis-ekf}
%\documentclass[twoside]{thesis-ekf}
%\documentclass[colorlinks]{thesis-ekf}
\usepackage[T1]{fontenc}
\PassOptionsToPackage{defaults=hu-min}{magyar.ldf}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listingsutf8,xcolor,caption,graphicx,amsmath,amssymb,amsthm, url, hulipsum, hyperref}
\footnotestyle{rule=fourth}

\def\lstlistingname{kód}

\graphicspath{{./pictures/}}

\newtheorem{tetel}{Tétel}[chapter]
\newtheorem{lemma}[tetel]{Lemma}
\theoremstyle{definition}
\newtheorem{definicio}[tetel]{Definíció}
\newtheorem{feladat}[tetel]{Feladat}
\theoremstyle{remark}
\newtheorem{megjegyzes}[tetel]{Megjegyzés}
\newtheorem*{megoldas}{Megoldás}

\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10}
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}

\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},
keywordstyle=\ttb\color{deepblue},
emph={},
emphstyle=\ttb\color{deepred},
stringstyle=\color{deepgreen},
frame=tb,
showstringspaces=false,
numbers=left,
stepnumber=1,
breaklines
}}

\newcommand\javastyle{\lstset{
language=Java,
basicstyle=\ttm,
otherkeywords={this, class},
keywordstyle=\ttb\color{deepblue},
emph={@Test,@Rule, @Before, @LargeTest, @RunWith, @Query, @Dao, @Delete, @Insert, @Override, MODE_PRIVATE, USERNAME_KEY, PASSWORD_KEY, PROTOCOL, FORM, HOST, PORT, APK_MEDIA_TYPE},
emphstyle=\ttb\color{deepred},
stringstyle=\color{deepgreen},
frame=tb,
showstringspaces=false,
numbers=left,
stepnumber=1,
breaklines
}}

\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

\lstnewenvironment{java}[1][]
{
\javastyle
\lstset{#1}
}
{}

\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

\newcommand\javaexternal[2][]{{
\javastyle
\lstinputlisting[#1]{#2}}}

\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}

\newcommand\javainline[1]{{\javastyle\lstinline!#1!}}

\begin{document}
\logo{\includegraphics[width=8cm]{eke-logo.pdf}}
\institute{Matematikai és Informatikai Intézet}
\title{Kliens-szerver kommunikáció\\Android platformon}
\author{Balajti-Tóth Kristóf\\Programtervező Informatikus BSc}
\supervisor{Tajti Tibor\\Tanársegéd}
\city{Eger}
\date{2019}
\maketitle
\tableofcontents
\listoffigures
\def\lstlistlistingname{Forráskódok jegyzéke}
\lstlistoflistings

\chapter*{Bevezetés}
\markboth{Bevezetés}{Bevezetés}

A szoftver fejlesztés egy nagyon komplex folyamat és rengeteg részletre oda kell figyleni.
Az elkészült programnak hatékonynak, hibamentesnek és gyorsnak kell lennie. Természetesen, mindezt határidőn belül kell teljesíteni.
Sajnos a biztonság nem egy első számú szempont egy megrendelő szemében, csak akkor ha már valami baj történt.
Inkább a gyorsaságon és a folyamatok automatizálásán van a hangsúly, ezért nem  meglepő, hogy a fejlesztés életciklusának tervezési szakaszában kevés figyelem fordul a szoftver biztonságossá tételére.

A statista.com \cite{statista} kutatása szerint 2020-ra több mint 4.78 billió telefon lesz használatban.
Ezzel a cégek is tisztában vannak és tudják, hogy ha még több emberhez szeretnék eljuttatni a szolgáltatásukat, akkor rendelkezniük kell saját mobilos applikációval.
A kérdés az, hogy ezt a hatalmas keresletet mennyire tudják a fejlesztők kielégíteni és még ha ki is tudják, milyen minőségű kódot tudnak előállítani.
A fejlesztőkkel szemben nagyon sok elvárást támasztanak a megrendelők és ahogy előbb is említettem a biztonság csak ritkán elvárás.
Véleményem szerint ha nem szentelnek elég figyelmet a behatolás tesztelésre és magára a biztonságra általánosságban, akkor annak elég súlyos következményei lehetnek.

A mobilos eszközöket célzó támadások száma hatalmas ütemben nő. Mindez azért lehetséges, mert figyelmen kívül marad a ,,secure coding''-nak nevezett gyakorlat.
Egy alkalmazásnak a sebezhetőségét különböző támadási vektoron is ki lehet aknázni.
Az elején, bennem többek között az a kérdés merült fel, hogy honnan tudható egy alkalmazásról, hogy sebezhető-e vagy sem.
Aztán azon is elgondolkoztam, hogy honnan lehet felismerni a sebezhetőségeket és hogy milyen súlyos hibák fordulhatnak elő.
A leghatékonyabb módszer ha megpróbáljuk visszafejteni az alkalmazást forráskódra.
Ezt angolul ,,reverse engineering''-nek nevezik.
A visszaállított fájlok olvashatósága nem lesz tökéletes, főleg ha obfuszkált \footnote{Az obfuszkáció célja röviden, hogy megnehezítse a visszafejtett kód olvashatóságát.} kóddal állunk szemben, de egy tapasztalt szem így is kitudja szúrni a gyakori hibákat.

A szakdolgozatomban Android platformra készült alkalmazások forrás fájlokká való visszaállításáról írok, valamint bemutatom hogyan valósítható meg a kliens-szerver kommunikáció egy Python programozási nyelvben írt REST\footnote{Representational State Transfer} API és egy Android platforma készült kliens segítségével.
Szó lesz arról, hogy hogyan tudunk fájlokat feltölteni, valamint letölteni a szerverről és értesítésekkel operálni.
A felhasználó egy egyszerű autentikáció után képes lesz \emph{.apk} fájlok feltöltésére, letöltésére és az elkészült projektben való navigálásra.
Hosszabb ideig tartó folyamatok állapotáról és elkészültéről értesítést kap a felhasználó és lehetősége lesz a forráskód alkalmazáson belüli megtekintésére és megosztására.
Ezzel egy hatékony és sokoldalú eszközt adva a tesztelők, kutatók és a terület után érdeklődők kezébe.
A projektet ,,Reverse Droid''-nak neveztem el.

\chapter{Fejlesztői környezetek}\label{kornyezetek}

\section{Android Studio}\label{androi_studio}

Az Android Studio jelenleg az egyetlen jól támogatott és minőségi fejlesztői környezet Android fejlesztéshez.
Régebben sok panaszt hallottam az emulátorára, hogy nagyon lassú és körülményes vele dolgozni.
Mára már egy pillanat alatt lehet futtatni a programunk és abszolút kényelmes lett a használata.
Azt is megmerem kockáztatni, hogy már teljes egészében ki tuja váltani a fizikai eszközt.
Az emulátor állapota menthető, ezáltal indításkor ott folytathatjuk, ahol abba hagytuk.
Azon kívül, hogy segítségével több különböző eszközön tesztelhetjük az alkalmazásunk, lehetőséget ad még a szenzorok, hálózati és GPS kapcsolat szimulálására. 
Rendelkezik APK elemzővel, vizuális felhasználó felület szerkesztővel és intelligens kód szerkesztővel is.

Az egyik kedvenc funkcióm a valós idejű profilozó, ami segítségével megtudjuk nézni valós időben, milyen erőforrásokat használ az alkalmazásuk.
Ez különösen hasznos, ha megakarunk találni egy memória szivárgást vagy egy olyan részt, ami a kelleténél jobban meríti az akkumulátorunk.
Említésre méltó még a flexibilis build rendszere is, a Gradle. 
Az Android Studio-val megtehetjük, hogy külön build típusokat hozzunk létre a különböző eszközökre.
Az \emph{instant run} funkció segítségével egyből tudjuk futtatni a kódban véghez vitt kisebb változtatásokat, anélkül hogy újraindítanánk az Activity~-t vagy újra buildelnénk az egész projektet és új APK~-t telepítenénk.
\cite{androidstudio}

\section{Pycharm Professional Edition}

A PyCharm is egy IDE \footnote{Integrated Development Environment (integrált fejlesztői környezet)}, mint az Android Studio.
Dolgozhatunk webes technológiákkal vagy mesterséges intelligenciával, a PyCharm megfelelő választás lehet bármilyen területen programozó számára.
A Pycharm mögött is a \emph{Jetbrains} cég áll. Ezt azért fontos megemlíteni, mert már 15 éve azon dolgoznak, hogy a legjobb és leghatékonyabb fejlesztői környezetek állítsanak elő.
Véleményem szerint ez sikerült is nekik. Az Android Studio-n és a Pycharm-on  is látszik, hogy minőségi termékek és rengeteget segítenek a fejlesztők mindennapjaiban.
Én a \emph{PyCharm Professional Edition}-t használtam, amihez a diákok ingyenesen hozzájuthatnak.
Mivel adatbázissal is dolgoznok, ezért a \emph{Community Edition} nem lett volna megfelelő.
Nem csak az adatbázis támogatást nyújt, hanem webes keretrendszer támogatást és profilozót is.
A távoli fejlesztés funkció is rendkívül praktikus. A fejlesztés közben egyszerűen tudtam feltölteni a szerverre a változtatásaimat.
A verzió kezelőknek is egyesített felületet nyújt, amivel jelentős időt spórolhatunk meg.\cite{pycharm}
Ez a lehetőség mindkettő fejlesztői környezetben elérhető.

\section{Postman}

Jelenleg a Postman a legnépszerűbb API\footnote{Application Programming Interface} tesztelésben használt eszköz.
A Postman kollekciók futtatható leírásai egy API-nak és sarok kövei a Postman beépített eszközeinek.
Ezeknek a beépített eszközöknek köszönhetően futtathatunk hálózati kéréseket, teszteket, debuggolhatunk és csinálhatunk mock szervereket is.
Ráadásul automatizáltan futtathatjuk a teszteket és egyszerűen elkészíthetjük és publikálhatjuk az API dokumentációját.

Én kizárólag dokumentáció készítésre és a végpontok tesztelésére használtam. Ettől természetesen sokkal több lehetőség rejlik benne.
Segítségével egyszeren publikálhattam az API dokumentációját, így lehetővé téve a felhasználást mások számára is.
A Postman a \url{https://documenter.getpostman.com/view/5052599/S11RKayE} oldalon található leírást készítette el számomra.
Különösen hasznos, hogy nem csak a végpontokat mutatja be hanem a kéréshez szükséges fejléceket, paramétereket és még a törzs típusát is.
A weboldalon ezeken felül kiválaszthatjuk, hogy milyen programozási nyelvben kívánjuk megírni a saját kliensünk.
Miután ezt megtettük, az oldal jobb oldalán megjelennek a kérésekhez tartozó nyelv specifikus példák.
Úgy gondolom, ez a funkció hatalmas segítséget nyújt a dokumentációt felhasználók számára.

\chapter{Platformok}\label{platformok}

\section{A szerver kiválasztása és felépítése}

Olyan szerverre volt szükségem, ami nem túl költséges, de mégis megfelelően testreszabható és gyors tárhelyet biztosít.
A választásom a Digitial Ocean felhő szolgáltatására esett. Az oldal felületén lehetőségünk van több, úgynevezett \emph{droplet}-et létrehozni, amik nem mások mint virtuális szerverek. 
Megadhatjuk milyen disztribúciót szeretnénk telepíteni, jelen esetben én az Ubuntu Linux 18.10-es verzióját választottam.

Szerencsére nem kellett új domain nevet vásárolnom, mert már rendelkeztem egyel.
A domain egyébként a \emph{Namecheap} oldalon van beregisztrálva.
Annyi volt a dolgom, hogy egy új aldomaint kellett készítenem a projekt számára.
Miután feltelepült a Droplet hozzárendeltem az IP\footnote{Internet Protocol} címét az előbb elkészített aldomainhez.
Ezzel biztosítottam, hogy domain név alapján is elérhető legyen a szerver.
Körülnéztem a konkurens cégek által nyújtott szolgáltatások között is, de én úgy láttam, hogy egyik se éri el azt az ár-érték arányt, amit a \emph{Namecheap} nyújt. 

Habár nagyon egyszerű volt a folyamat, az elkészült projektben mégsem ezt a folyamatot választottam, hanem a Digital Ocean által nyújtott ,,one-click apps'' menüben egyszerűen kiválasztottam a Docker alkalmazást és az elkészült képfájlt ezen futtattam. 
Így automatizálva a szerver telepítésének folyamatát és megspórolva a Docker telepítését és konfigurálását.
Erről még a \nameref{szerveren_hasznalt_technologiak} fejezet \nameref{docker} alfejezetében bővebben írok.

\section{Mobil platform választása}

A mobilos operációs rendszerek közül az Androidot választottam. Bevallom őszintén, nem volt nehéz a döntés. 
Android platform rengeteg olyan lehetőséget biztosít, amivel a többi platform nem szállhat versenybe.
Itt gondolok az egyszeri és nem megújuló fizetésre a fejlesztői fiókért, valamint az iOS-el ellentétben a fejlesztői környezete elérhető mind a három fő operációs rendszerre (Linux, macOS, Windows).
Számomra ezek elég nyomós érvek voltak, ezért döntöttem úgy, hogy Android platformra fog először elkészülni a program.
A Windows Phone a Microsoft cégnek volt egy próbálkozása, ami végül kudarcba fulladt, ezért ez az opció nem jöhetett szóba.

A többi mobilos operációs rendszerrel ellentétben az Android nyílt forráskódú és a piac jelentős részét uralja.
Engem különösen megfogott az általa nyújtott szabadság és testre szabhatóság.
Az iOS ezzel ellentétben arról híres, hogy egyszerű és megbízható a használata.
Viszont jelen vannak olyan megkötések, amik mind a végfelhasználókat és mind a fejlesztőket limitálják.
Gondolok itt a minimális testre szabhatóságra és a nagy részt zárt forráskódra.
Itt most nyilván nem szeretném részletezni, hogy melyik operációs rendszer a jobb vagy éppen rosszabb, mert mindegyik rendszernek megvan az előnye, illetve a hátránya.
Inkább csak a személyem érveimet és tapasztalataimat sorakoztatom fel, amik alapján platformot választottam.

Fontos megemlíteni, hogy az Android rendszer nem csak mobil telefonokban terjedt el.
Jelen van az okos televíziókban (Android TV), autókban (Android Auto), okos órákban (Wear OS) és IoT\footnote{Internet of Things}-ben is (Android Things).
Ezek az Android által úgymond eredmények annak is köszönhetőek, hogy a Google felvásárolta az Android céget és azóta ők tartják karban.

Természetesen nem csak jó tulajdonságokkal rendelkezik, hanem bizony van néhány hátránya is.
Ide tartozik például a gyártóktól függő frissítések. Tegyünk fel, hogy új biztonsági rést fedeztek fel az Android operációs rendszerben.
A Google általában ezekre meglehetősen gyorsan reagál és néhány napon belül frissítést ad ki az eszközeire (Nexus, Pixel).
Azoknak a gyártóknak akiknek saját testre szabott rendszerük van, jóval tovább tart orvosolni a hibát.
Ez az időtartam a mai napig hónapokban mérhető, de persze ez függ az adott cégtől és a hiba súlyosságától. 

Számomra ezek voltak a legnyomósabb érvek a rendszer kiválasztásában.
A mai napig úgy gondolom, hogy ebben a platformban van a legnagyobb potenciál a fejlesztők és felhasználók számára egyaránt.

\chapter{Felhasznált technológiák}\label{technologiak}

\section{Verzió kezelés}

Egy verzó kezelő rendszer képes kezelni egy fájl vagy akár több fájl módosításait olyan módon, hogy lehetőségünk legyen időben ,,visszamenni'' és megnézni egy fájl bizonyos verzióját.
A Linux kernel forráskódja hatalmas méretű és a Git verzió kezelőt használják a fejlesztéshez.
Ez azért érdekes, mert nagyon sok ember dolgozik egy óriási kódbázissal és a Git mégis képes hatékonyan kezelni a változásokat.
A alábbi listában látható, hogy miért bíznak meg benne egy ilyen nehéz feladat esetében és hogyan teljesíti a Git minden elvárásukat:

\begin{itemize}
	\item Atomosság
	\item Teljesítmény
	\item Biztonság
\end{itemize}

Az atomosság biztosítja, hogy az adatok ne vesszenek el és ne történjen verzió eltérés részlegesen befejezett műveletek miatt.
A gyorsasága mellett nem használ fel jelentős mennyiségű tárhelyet, ellentétben a többi verzió kezelő rendszerrel.
Ha Git-et használunk biztosra mehetünk, hogy senki sem módosítja a fájlok tartalmát. Ez a SHA-1 kivonatolásnak köszönhető.\cite{git}

A fentiek fényében nyilvánvaló, hogy a Git mellett döntöttem, ami széles körben elterjedt a szoftver fejlesztők között.
A Git egy ingyenes és nyílt-forráskódú elosztott verzió kezelő rendszer. Úgy készült, hogy gyorsan és hatékonyan tudjon kezelni kis és nagy projekteket is egyaránt.
Már a project kezdetekor készítettem egy privát Github repository-t, hogy nyomon tudjam követni a változtatásaimat és esetleges hiba esetén visszaállítani egy korábbi verzióra.

A Github nem összetévesztendő a Git-el, mert a Git a forráskód változtatásainak kezelésére szolgál (lokálisan), a Github pedig egy tárhelyet nyúlt a verzió kezelt könyvtárak és fájlok tárolására.
A projekt fejlesztése alatt több gépről dolgoztam és Github a segítségével biztosítani tudtam, hogy mindenhol elérjen a projektek legfrissebb változtatásait.
Lényegében egy központi szerverként szolgált számomra.

\section{Folyamatos integrálás}

A folyamatos integrálás egy szoftver fejlesztési gyakorlat, ahol a csapat tagjai sűrűn építik be munkájukat a kódbázisba.
Pontosabban megfogalmazva ez egy extrém programozási gyakorlat és naponta több integrációhoz vezet.
A technológia arról szól, hogy ha egy feladat elkészült akkor azt egyből beépítjük a rendszerbe.
Minden integráció hitelesítve van egy automatikus build rendszer által (egységtesztekkel együtt) annak érdekében, hogy minél hamarabb észrevegyük az hibákat.
Ezek után természetesen minden egységtesztnek sikeresen le kell futnia.
Sok csapat úgy gondolja, hogy ez a megközelítés jelentősen kevesebb problémához vezet és meggyorsítja a fejlesztés menetét.\cite{continuous_integration}

Több nagy cég is a CircleCi szolgáltatását használja a folyamatos integráláshoz, ilyen például a \emph{Facebook}, \emph{Spotify} és a \emph{GoPro}.
A CircleCi összeköthető a Github-al, így kényelmesen tudjuk csatolni az ott tárolt projektjeinkket.
A konfigurációs fájl létrehozása pedig végtelenül egyszerű, ha követjük a dokumentációt.
\Aref{circleci}.~képen látható, hogy minden egyes változtatáskor lefutnak a tesztek.
Ezek a tesztek minden alkalommal egy tiszta konténerben vagy virtuális gépen futnak.
Jelen esetben az Android program egy ilyen Docker konténerben fut, aminek a neve \emph{circleci/android:api-28-alpha}.
Az eredményről mindig értesítést kapunk, így egyből tudhatjuk azt is, ha egy build nem volt sikeres.

\begin{figure}[!h]
	\centering
	\includegraphics[width=15cm]{pictures/circleci}
	\caption{Project buildek követése a CircleCi felületén.}
	\label{circleci}
\end{figure}

\newpage

\section{Szerveren használt technológiák}\label{szerveren_hasznalt_technologiak}

\subsection{Flask}

A szervert a Flask webes mikro keretrendszer felhasználásával készítettem el, amit Python programozási nyelvben írtak.
Attól, hogy mikro keretrendszer még nem jelenti azt, hogy kevesebb tud mit a többi keretrendszer.
Erős alapot nyújt az alapvető szolgáltatásokkal, miközben a kiegészítők nyújtják a többit.
Ezzel a lehetőséggel magunknak tudjuk kiválasztani a kiegészítő csomagokat.
Ezáltal képesek vagyunk egy olyan programot felépíteni, ami pontosan azt tartalmazza amire szükségünk van és semmi fölöslegeset.

A Flask nem támogatja natívan az adatbázis elérést, web formok validálását, felhasználói autentikációt és egyéb magas szintű feladatokat.
Ezek és más egyéb kulcs szolgáltatások, amikre egy webes applikációnak szüksége van kiegészítőkön keresztül elérhető.
Fejlesztőként lehetőségünk van egyesével kiválogatni vagy éppen magunktól megírni azokat a kiegészítőket, amik az aktuális projekthez kellenek.
\cite{flask}

Úgy gondolom, hogy sokkal hatényobban programot lehet írni, ha csak azt építjük bele a szoftverbe, amire tényleg szükségünk van.
Nekem csak kettő kiegészítőre volt szükségem, mivel a többi funkcionalitást alapból nyújtja a keretrendszer.

\subsubsection{Flask-Testing}

Az egyik ilyen a ,,Flask-Testing'' csomag, amire az egységtesztek miatt volt szükségem.
Segítségével rendkívül egyszerűen és hatékonyan tudjuk tesztelni az alkalmazásban található végpontokat.
\Aref{flask_test}.~kódrészletnél megfigyelhetjük a sokoldalúságát és előnyeit.
Külön függvényeket tudunk használni a HTTP státuszkódok tesztelésére és megfigyelhetjük, hogy a teljes kérés elküldése egy sorban megoldható.
Használata számomra nagyon könnyű volt és a dokumentáció minden felhasználási esetre kitért és lehetővé tette, hogy kényelmesen teszteljem a JSON\footnote{Javascript Object Notation} válaszokat.
A készítők azt ajánlják, hogy tegyünk minden tesztet egy nagy fájlba, mert így kényelmesen tudjuk egyszerre futtani őket.

\pythonexternal[caption=Bejelentkezés tesztelése helyes adatokkal.,label=flask_test]{./codes/flask_test.py}

\subsubsection{Flask-Bcrypt}

Mivel alapból a Flask keretrendszer nem biztosít titkosítás, keresnem kellett egy külső megoldást.
A másik ilyen csomag amit felhasználtam, a ,,Flask-Bcrypt'' volt.
Nagyon rossz gyakorlat, ha a jelszavakat titkosítás nélkül tároljuk az adatbázisban.
Ennek elkerülése érdekében választottam a bcrypt algoritmust szolgáltató csomagot, ami kifejezetten erre a célra készült.

\subsection{SQLite}

Az SQLite egy nyílt forráskódú szoftver csomag, ami relációs adatbázis kezelő rendszert biztosít.
Relációs adatbázis rendszereket arra használjuk, hogy a felhasználó által meghatározott rekordokat nagy méretű táblákban tároljunk.
Az adat tárolás és kezelés mellett, az adatbázis motor komplex lekérdezéseket dolgoz fel.
Néhány meghatározó funkciója az SQLite adatbázisnak:

\begin{enumerate}
	\item
	\begin{description}
		\item[Szerver mentes] Az SQLite-nak nincs szüksége külön szerver folyamatra vagy rendszerre a működéshez. Az SQLite könyvtár közvetlenül kezeli a tárhely fájlokat.
	\end{description}
	\item
	\begin{description}
		\item[Nulla konfiguráció] Ha nincs szerver, nincs konfiguráció sem. Úgy csinálhatunk SqLite adatbázist, mintha fájlt hoznánk létre.
	\end{description}
	\item
	\begin{description}
		\item[Platform független] Az egész adatbázis példány egy darab platform független fájl, ami semmilyen adminisztrációt nem igényel.
	\end{description}
	\item
	\begin{description}
		\item[Önálló] Egy darab könyvtár tartalmazza az egész adabázis rendszert, ami közvetlenül az alkalmazásba integrálódik.
	\end{description}
	\item
	\begin{description}
		\item[Tranzakciós] Lehetővé teszi a biztonságos hozzáférést más szálakból vagy folyamatokból.
	\end{description}
	\item
	\begin{description}
		\item[Kifejezetten megbízható] A SQLite fejlesztői csapata nagyon komolyan veszi a forráskód tesztelését.
	\end{description}
\end{enumerate}

Összességében az SQLite egy funkcionális és fexibilis relációs adatbázis környezet, ami csak minimális erőforrást igényel.
\cite{sqlite}
Nem mellesleg ez a legtöbbet használt adatbázis motor a világon. 
Számtalan alkalmazás használja és Android platformon is ez az alapértelmezett adatbázis.
Ha többet szeretnénk megtudni róla, akkor azt megtehetjük a \url{https://www.sqlite.org/index.html} oldalon.

\subsection{Pusher Beams (Python Server SDK)}\label{pusher_server}

A szerverről való értesítés küldéshez a Pusher Beams SDK\footnote{Software Development Kit}-ját használtam.
A Beams SDK lehetővé teszi, hogy egyszerűen küldjünk push értesítést ,,érdeklődési'' körök alapján és platformtól függetlenül.
Ingyenesen és korlátlanul küldhetjük ezeket az értesítéseket. Erről bővebben olvashatunk a \url{https://docs.pusher.com/beams} oldalon.
Ha kimondottan a szerver oldali python dokumentációt szeretnénk elolvasni, azt megtehetjük itt: \url{https://docs.pusher.com/beams/reference/server-sdk-python}
A szerver és kliens is oldal implementációja is nagyon egyszerű és jól dokumentált, de ha mégis problémánk támadna az online ügyfélszolgálatuk is végtelenül segítőkész.

Bevallom, amikor implementáltam a szerverről való üzenetküldést nem ment minden simán.
Az volt a probléma, hogy csak azt az értesítést kaptam meg amelyik nem tartalmazott plussz adatot az értesítés címén és leírásán kívül.
Fel kellett keresnem őket, mert hiába követtem a dokumentációkat nem értettem a hiba okát.
Az üzenetemre kifejezetten gyorsan (egy napon belül) válaszoltak és kérték, hogy küldjek több információt.
Hamar kiderült, hogy a problémát az FCM\footnote{Firebase Cloud Messaging} okozza, ami nem engedi, hogy egyszerre küldjünk értesítést és adatot.
Itt kiegészítésként fontos megemlíteni, hogy a Pusher a Firebase Cloud Messaging által küldi az értesítéseket.
Miután rávilágítottak a hiba okára, egyből megoldást ajánlottak és frissítették a dokumentációjukat.
Úgy sikerült kikerülni ezt a limitációt, hogy kettő darab értesítést kell küldeni.
Az első csak magát az értesítést tartalmazza, a második pedig kizárólag az adatok küldéséért lesz felelős.
Természetesen a második értesítésnek nem lesz vizális reprezentációja a kliens oldalon.

\subsection{Docker}\label{docker}

A Docker az egy nyílt forráskódú motor, ami automatizálja az alkalmazások üzembe helyezését konténereken belül.
Úgy lett tervezve, hogy egy pehely súlyú és gyors környezetet nyújtson, amiben hatékonyan tudjuk futtatni a kódunk.
Célja még, hogy hordozhatóvá és könnyen buildelhetővé tegye az alkalmazásunk.
Szolgáltatás orientált architektúrára ösztönöz és azt ajánlja, hogy minden konténerben csak egy alkalmazás fusson.\cite{docker}

\subsubsection{Képfájlok}

A konténereinket képfájlokból futtatjuk.
Rétegezett formátumuk van, ami lépésről-lépésre épülnek fel egy sorozat parancs alapján.
Tulajdonságaikat tekintve hordozhatóak, megoszthatóak, tárolhatóak és frissíthetők.
A következő paranccsal tudunk képfájlt készí

\begin{center}
	\texttt{\$ docker build .}
\end{center}

Minden Docker képfájl rendelkezik egyedi azonosítóval.
A példa kedvéért az én képfálom az ,,edd116d82f90''-es azonosítót kapta, de használatkor nem fontos az egészet kiírni.
Megtehetjük azt is, hogy a 9898-as porton futú szolgáltatást a helyi 80-as portra publikáljuk és így futtatjuk.
Ezt a következő paranccsal tehetjük meg:

\begin{center}
	\texttt{\$ docker run -p 80:9898 edd11}
\end{center}

\subsubsection{Konténerek}

A konténerek lényegében a futó képfájlok példányai.
Ha elindítunk egy képfájt és megnyitunk egy új terminál ablakot, akkor az alábbi paranccsal megtekinthetjük a futó konténert.

\begin{center}
	\texttt{\$ docker container ls}
\end{center}

A parancs kiírja többek között a publikált portot, a konténerben futó parancsot és a képfájl azonosítóját is.

\subsubsection{Dockerfile}

A szakdolgozatom szempontjából fontos említést tenni a Dockerfile-ról is.
A Dockerfile egy DSL\footnote{Domain Specific Language} nyelvet használ útasításokkal, ami segítségével képfájlokat tudunk készíteni.
Valójában ez a szöveges dokumentum tartalmazza azokat a parancsokat, amik egy képfájl felépítéséhez/elkészítéséhez szükségesek.
Segítségével bárki automatikusan készíthet egy Docker képfájlt, amit aztán egyszerűen lehet futtatni.

\subsubsection{Docker Hub}

A Docker Hub biztosítja azt a platformot, ahol bárki kereshet és megoszthat konténereket.
Kézzel nagyon körülményes lett volna a képfájl verzióinak követése és publikálása, ezért igénybe vettem a Docker Hub szolgáltatását.
Ez a szolgáltatás nem más, mint az automatikus buildek készítése.
A Docker Hub képes külső forráskódból képfájlt készíteni és azt publikálni.
Összetudjuk csatolni a Github projektjeinket a Docker Hub-al. 
Ezzel hozzájárulva ahhoz, hogy minden egyes változtatásnál a Docker Hub újra buildelje a képfájlt és publikálja a frissített verziót.
Az alkalmazás megtekinthető a \url{https://hub.docker.com/r/tothkris/reversedroid} oldalon.

\begin{figure}[!h]
	\centering
	\includegraphics[width=15cm]{pictures/docker_hub}
	\caption{A publikált applikáció Docker Hub-on.}
	\label{dockerhub}
\end{figure}

\subsection{Apktool}

Az Apktool egy olyan eszköz, aminek a segítségével vissza tudjuk fejteni a harmadik féltől származó, zárt forrású, bináris Android alkalmazásokat.
Majdnem eredeti az állapotukba tudja dekódolni a forrásokat és akár újra is tudja buildelni az alkalmazást néhány módosítással.
Ezek a tulajdonságok vonzák mind a jó és rossz szándékkal rendelkező személyeket.
A rossz számdékkal rendelkezőket természetesen azért, mert ezt a technológiát lehet kalózkodásra és egyéb illegális tevékenységre használni.
A jó számdékkal rendelkezőeket pedig azért, hogy analizálják és megakadályozzák az elterjedését ezeknek a kártékony és illegális szoftvereknek.

Az alábbi tulajdonságokkal rendelkezik:

\begin{itemize}
	\item Források visszaállítása majdnem eredeti formájukba
	\item Újra buildelése a dekódolt forrásoknak bináris APK/JAR fájlba
	\item Smali kód debuggolás
\end{itemize}

Az eszköz letölhető a \url{https://github.com/iBotPeaches/Apktool} oldalról.

\subsection{dex2jar}

A  szerver oldalon kulcs szerepet játszott a \emph{dex2jar} nevű eszköz.
Ahogy a neve is sugallja, az Android .dex fájlokat konvertálja .class fájlokká.
Tehát bináris formátumot alakít egy másik bináris formátumba.
Jelen esetben nem csak egy programról beszélünk, mert valójában több eszközt foglal magába.
Az Android telepítő fájl kitömörítése után, az alkalmazás forráskódja egy \emph{classes.dex} fájlban található meg.
Ez a fájl byte kódot tartalmaz az ART\footnote{Android Runtime} számára és ezt kellett átalakítani .jar formátumba, amivel már a decompiler dolgozni tud.
Szerencsére aktív fejlesztés alatt áll és letölthető a \url{https://bitbucket.org/pxb1988/dex2jar} oldalról

\subsection{jd-cmd}

A visszefejtéshez kötődik még a \emph{jd-cmd} elnevezésű program.
Vannak olyan helyzetek, amikor nem mindig áll rendelkezésünkre GUI\footnote{Graphical User Interface (grafikus felhasználói felület)}.
A szerveren például nincs lehetőségünk ilyet használni, ott csak a parancssorra hagyatkozhatunk.

A \emph{jd-cmd} egy Java decompiler, ami .class fájlokat alakít vissza .java forrásfájlokká.
Már ahogy a bevezetésben is leírtam, ezeknek a forrásoknak a visszaállítása nem mindig megfelelő.
A visszaállítás sok tényezőtől függ, de ez itt most nem lényeges.

A \url{https://github.com/kwart/jd-cmd} oldalon megtekinthetjük és letölthetjük a programot.
A használatához szükségünk van a Java 6-os verziójára vagy attól újabbra.
Viszonylag sok paramétert adhatunk át, amik segítségével testreszabhatjuk a kimenetet.
Ilyenre példa a \emph{--displayLineNumbers}, ami a sorszámokat jeleníti meg a visszafejtett osztályokban.

\subsection{JSON}

A JSON egy platformok közötti adatátvitelre szolgáló formátum.
Az adatátviteli formátum egy olyan szöveges formátum, amit különböző platformok közötti adat cserére használnak.
Egy másik széles körben használt adatátviteli formátum az XML\footnote{Extensible Markup Language}.
Ezek biztosítják a nagyon eltérő rendszerek közötti adatváltást.
A JSON egy olyan formátum, amin megegyeztek ezek a rendszerek adat kommunikáció céljából. \cite{json1}
Kettő struktúrára épül:

\begin{enumerate}
	\item
	\begin{description}
		\item[Kulcs-érték párok] Ez a koncepció nagyon elterjedt a számítástechnikában és több programozási nyelvben van megfelelője. 
	\end{description}
	\item
	\begin{description}
		\item[Listába rendezett értékek] A legtöbb nyelvben megfelel a tömböknek, vektoroknak és listának.
	\end{description}
\end{enumerate}

Ezek olyan univerzális adatszerkezetek, amiket gyakorlatilag minden programozási nyelv támogat ilyen vagy olyan formában.
Ésszerűnek tűnik tehát, hogy az az adatformátum, amelyet programozási nyelvek kommunikációjához kívánunk használni, szintén ezekre a szerkezetekre épüljön.\cite{json2}

\javaexternal[caption=Egy nagyon egyszerű példa a szervertől érkező JSON válaszra., label=json_example]{./codes/result.json}

Emberek számára is könnyen olvasható és írható, ahogy ez \aref{json_example}.~példán is látszik. 
A szakdolgozatomban is fontos szerepet töltbe, ugyanis a klien-szerver kommunikáció teljes egészében erre alapul.
Véleményem szerint sokkal átláthatóbb és egyszerűbb, mint például az XML társa.

\section{Androidon használt technológiák}

\subsection{AndroidX}

Az AndroidX egy nyílt forráskódú projekt, amit az Android fejlesztői csapata használ library-k fejlesztéshez, teszteléséhez és kiadásához a Jetpack-en belül.
Az eredeti support library-hez képest az AndroidX egy jelentős fejlődés. Ahogy a support library-t is, az AndroidX-et is az Android operációs rendszertől függetlenül tudjuk használni és biztosítja a visszafelé kompatibilitást.
Az AndroidX teljesen felváltja a support library-t azáltal, hogy azonos funkciókat biztosít és új könyvtárakat.\cite{androidx}
Ezen felül az AndroidX a következő funkciókat tartalmazza: 

\begin{enumerate}
	\item Minden csomag egy konzisztens névtérben van, ami ,,androidx''-el kezdődik.
	\item A support library-vel ellentétben az AndroidX csomagok külön vannak karbantartva és frissítve.
	\item Az összes új support library fejlesztés az AndroidX könyvtárban fog történni. Ez magába foglalja az eredeti support library fenntartását és az új Jetpack komponensek bevezetését.
\end{enumerate}

\subsection{OkHttp}

A modern alkalmazások a HTTP \footnote{HyperText Transfer Protocol} protokollal dolgoznak. 
Segítségével adatokat tudunk küldeni és fogadni.
Ha hatékonyan használjuk a HTTP protokolt, akkor gyorsabban tudjuk az adatokat betölteni és sávszélességet spórolhatunk meg. 

Az OkHttp egy HTTP kliens, ami a kezdektől fogva hatékonyságra lett tervezve.
Az alábbi lista tartalmazza két fontos tulajdonságát a sok közül:

\begin{enumerate}
	\item Az átlátszó GZIP csökkenti a letöltés méretét.
	\item A válaszokat cache-ben tárolja, ezért ismétlődő kéréseknél elkerülhető a hálózat használata.
\end{enumerate}

Akkor sem omlik össze, ha problémás a hálózat, valamint csendben helyreáll a gyakori kapcsolati problémák esetében is.
Ha a szolgáltatásunknak több IP címe lenne, akkor az alternatív IP címekkel próbálkozna kapcsolati hiba esetén.
Ez szükséges IPv4+IPv6 használatakor és olyan szolgáltatások esetében, amik redundáns adat központokban vannak.
Támogatja a modern TLS funkciókat, ami a biztonságos adatátvitelért felelős.

Az OkHttp használata egyszerű. A kérés/válasz API-ja builder tervezési mintára épült, amit nagyon könnyű használni.

Lehetőséget ad szinkronizált (egyidejű) blokkoló hívásokra és aszinkron hívásokra is ,,callback''-ek segítségével.
A könyvtár támogatja az Android 5.0+ (API szint 21+) verziókat és támogatja a Java 8-at, valamint az attól felfelé lévő verziókat.
Az OkHttp hivatalos dokumentációja megtekinthatő a \url{https://square.github.io/okhttp/} oldalon.

\subsection{Pusher Beams (Java Client SDK)}

A Pusher Beams SDK-járól már némi említést tettem a \nameref{pusher_server} alfejezetben, csak ott a szerver oldalon volt a lényeg.
Bonyodalommentessé teszi az eszköz tokenek kezelését és az interakciót az Apple és a Google által biztosított üzenetküldő szolgáltatásokkal.

A Pusher nagyon sokoldalú API-val és SDK-kal rendelkezik. 
Ezek közül a Beam egy fejlesztő barát eszköz, aminek a segítségével értesítéseket küldhetünk.
Számos mobil automatizálási eszköz javasolja a promóciós értesítések küldését, amiket nem mindig szeretnek a felhasználók és leiratkoznak.

A Beam-mel egyenesen a programból indíthatjuk az értesítések küldését a valós alkalmazásban történő eseményekre alapozva. 
Így a felhasználók kevésbé fogják megunni az értesítéseket is törölni esetlegesen az appot. 
Íme néhány példa a felhasználást illetően:

\begin{itemize}
	\item Étel kiszállítással kapcsolatos folyamatos értesítések
	\item Játékokban pontok alapján való értesítés küldés
	\item Tranzakciós értesítések
\end{itemize}

A felhasználásra nekem ezektől eltérő tervem volt, de alapvetően hasonló célra alkalmaztam.
Én a felhasználókat az elkészült fájlokról értesítettem, ami kulcs szerepet játszik a programban.
A szerverről érkező értesítésben adatokat is küldök, amik nélkül nem lehetne letölteni a fájlokat.
Ebből is látszik, hogy nagy mértékben erre a szolgáltatásra épül a szoftver.

\subsection{Room}

A Room egy absztrakciós réteget nyújt az SQLite adatbázishoz, ezzel lehetővé téve az egyszerűbb és hatékonyabb adatbázis elérést.
Segítségével sokkal egyszerűbben tudtam kezelni az SQLite adatbázist, mert nem kellett adatbázist leíró osztályt és hosszú lekérdezéseket írnom.
Ami külön tetszett benne, hogy az SQL utasításokat fordítási időben ellenőrzi. 
A Room használatakor annotációk segítségével tudjuk összekötni a Java POJO\footnote{Plain Old Java Object} osztályokat az SQLite adatbázist.

3 fő komponense van:

\begin{enumerate}
	\item
	\begin{description}
		\item[Adatbázis] Az \emph{@Database} annotációval rendelkező osztálynak az alábbi feltételeket kell kielégítenie.
	\end{description}
	\begin{enumerate}
		\item Absztrakt osztálynak kell lennie, ami a \emph{RoomDatabase} osztályból származik.
		\item Tartalmaznia kell az adatbázishoz tartotó entitás listát az annotáción belül.
		\item Rendelkezik egy olyan metódussal, aminek nincsen paramétere és visszatér egy \emph{@Dao}-val annotált osztállyal.
	\end{enumerate}
	\item
	\begin{description}
		\item[Entitás] Egy táblát reprezentál az adatbázisban.
	\end{description}
	\item
	\begin{description}
		\item[DAO] Az adatbázist elérő metódusokat tartalmazza..
	\end{description}
\end{enumerate}

Az alkalmazás a Room adatbázist használja, hogy megkapja az adatbázishoz társított DAO-kat.
Ezután az alkalmazás, ezeket a DAO-kat használja az entitások adatbázisból való eléréséhez.
A megkapott entitásokat ért változtatásokat egyszerűen vissza tudjuk menteni az adatbázisba.
Végül, az alkalmazás entitást használ, hogy lekérjen és beállítson értékeket a tábla megfelelő oszlopaiba az adatbázison belül.\cite{room}

\Aref{room}.~kódrészletben kiemeltem egy DAO\footnote{Data Access Object} interfészt.
Lényegében, ez a DAO nyújtja a hozzáférést az adatbázis réteghez.
Jól látható, hogy annotációkkal kell megjelölni a metódusokat, annak függvényében, hogy milyen utasítást szeretnénk végrehajtani.
Ahol paraméterben SQL\footnote{Structured Query Language} utasítást látunk, az mind fordítási időben ellenőrizve van.
Ez azért nagy segítség, mert nem kell aggódnunk szintaktikai hibákon, illetve azon, hogy az adott tábla nem létezik.
\Aref{room}.~kódrészletben látható egy \emph{listNotifications(String username)} metódus, aminek a paramétere szerepel az SQL utasításban is egy kettőspont után.
A Room elvégzi ezeknek a paramétereknek az összehasonlítását és hibát dob, ha eltérést talál.
Lehetőségünk van több paramétert is átadni, ezáltal robosztusabb lekérdezéseket valósíthatunk meg.

\javaexternal[caption=A NotificationDao interfész.,label=room]{./codes/NotificationDao.java}

\subsection{CodeView}\label{code_view}

A forráskód megjelenítését nem lett volna célszerű nulláról felépíteni, ezért inkább kész megoldások után néztem.
Kutatásaim során, nem találtam megfelelő natív Android komponenst, amivel kivitelezhető lett volna a forráskód megjelenítése.
Ezt úgy értem, hogy a kijelölést nem lehet megoldani egy egyszerű \emph{TextView} osztállyal.
Mindenképpen kellett egy olyan könyvtár, ami megbízható és elegendő funkcionalitást és testreszabhatóságot nyújt.
Jó pár könyvtárat végig kellett próbálnom, mire ráakadtam az igazira.
Találkoztam olyannal, amelyik nem megfelelően töltötte be a kódot és nem is volt megbízható.
Voltak olyanok is, amelyeket nagyon régóta nem voltak karbantartva és elavult kód bázissal rendelkeztek.
Találtam aktív fejlesztés alatt lévőket is, de azok többnyire még kiforratlan állapotban voltak és nem rendelkezdtek elegendő funkcióval.

A megvalósítást ezek a könyvtárak, úgy végezték el, hogy lényegében egy \emph{WebView} komponensbe töltötték be a forráskódot, amit aztán különböző JavaScript keretrendszerek segítségével színeztek ki.
A választásom egy olyan könyvtárra esett, ami a \emph{highlight.js} keretrendszert használja.
Ez biztosít több különböző témát szintaktikai kijelölésre és amit még fontosabbnak tartok, hogy automatikusan felismeri a domináns programozási nyelveket, mint a \emph{Java}, \emph{Python} vagy \emph{Ruby}.
Így sokkal kényemesebb a használata, mert nem kellett kiterjesztés alapján megadni az adott nyelvet.
Néhány funkció hiányzott ugyan, mint például a két ujjal való nagyítás, kicsinyítés és a kezdő betű méret beállítása.
Ezeknek a támogatását sikerült viszonylag egyszerűen megoldani, hiszen a \emph{CodeView} a \emph{WebView} osztályból származik és rendelkezik a megfelelő metódusokkal.
\Aref{codeviewimplementation}.~kódrészletben a \emph{CodeView} megvalósítása és kiegészítése látható, alatta pedig \aref{codeview}.~képen látható a forráskód megjelenítése az alkalmazásban.

\javaexternal[caption=A CodeView könyvtár felhasználása és kiegésztése.,label=codeviewimplementation]{./codes/codeview.java}

\begin{figure}[!h]
	\centering
	\includegraphics[width=15cm]{pictures/codeview}
	\caption{A visszafejtett forráskód megjelenítése szintaktikai kijelöléssel.}
	\label{codeview}
\end{figure}

\newpage

\subsection{Espresso}

Az Android Studio rendelkezik jó pár funkcióval, amikről már tettem említést.
Amit szándékosan kihagytam, az a UI\footnote{User Interface} tesztek felvétele.
Az Espresso Test Recorder funkció által megtehetjük, hogy nem kézzel írjuk a teszteket, hanem felvesszük őket.
Feltudjuk venni az interakcióinkat az alkalmazással és ellenőrizni tudjuk az elemeket a felhasználói felületen, valamint biztosítani tudjuk az adott pillant kép helyességét.
Az Espresso Test Recorder veszi az elmentett teszt felvételt és automatikusan generál egy hozzátartozó UI tesztet, amit aztán futtatni tudunk az alkalmazásunk tesztelése érdekében.

Espresso Test Recorder az Espresso Testing keretrendszer alapján írja a teszteket, ami egy API az AndroidX Test-ben.
Segít megbízható és tömör UI teszteket írni a felhasználói interakcióra alapozva.
Állíthatunk elvárásokat és interakciókat anélkül, hogy hozzáférnénk az alkalmazás nézeteihez és activity-jeihez.
Ez a struktúra optimizálja a tesztek futási idejét. \cite{espresso}

A projektem esetében nem volt ilyen egyszerű a helyzet.
Mindenképpen segített, hogy fel tudtam venni a teszteket, de vegyük a következő helyzetet.
Tegyük fel, hogy a bejelentkezés folyamatára már készen van a teszt.
Amikor Espresso-val tesztet veszünk fel, az alkalmazás tiszta állapotról indul.
Ez az jelenti, hogy ha bármilyen bejelentkezés utáni interakciót szeretnénk felvenni, akkor a teszt a bejelentkezéssel együtt kezdődik.
Az ilyen problémákat manuálisan kell kikerülni.

\Aref{espressotest}.~kódrészletben megfigyelhető, hogy egy \emph{@Before} annotációval ellátott metódusban elmentettem egy teszt felhasználó nevet és jelszót.
Ezután pedig egyszerűen egy Intent segítségével elindítottam az Activity-t.
Mindez nem volt elegendő ahhoz, hogy sikeresen tovább mehessek ugyanis bejelentkezés után történik a különböző engedélyek ellenőrzése.
Az Espresso arra is nyújt megoldást, hogy ezeket az engedély kéréseket automatikusan elfogadjuk a tesztekben a \emph{GrantPermissionRule} osztály segítségével.

\javaexternal[caption=Espresso UI teszt az adatok törléséhez.,label=espressotest]{./codes/test.java}

\subsection{Material Design 2.0}

Az alkalmazás elkészítésekor próbáltam figyelembe venni a felhasználói interfésszel kapcsolatban támasztott ki nem mondott elvárásokat.
Korábbi Play Store-ban publikált alkalmazásaim alapján mondhatom, hogy a felhasználónak az app megjelenése legalább olyan fontos, mint a funkcionalitása.
A Google már korábban, az Android 5.0 (API verzió 21) verzióval hozta be az akkoriban még újnak számító Material Design-t és teljesen megreformálta az Android platform felületét.
Sok embernek tetszettek az élénk színek és a vetett árnyákok, amik meghatározó részei voltak a komponenseknek. Persze, ez nem volt tökéletes.
A nevéből is ered, hogy az anyagokból kiindulva és azok egymásra pakolásával született meg a dizájn. 
Kicsit pontosabban fogalmazva a Material Design irányelveket foglal össze, amiket nem fontos követni, de ajánlott. 
A Material Design 2 nem hozott hatalmas eltéréseket elődjéhez képest, inkább csak letisztultabb lett, ami szimplán jobb vizuális élményt nyújt.
Az Android platformot tekintve új komponensek érkeztek, ezek közé tartozik a \emph{BottomAppBar} és a \emph{Chip}.

Miután az Android Studio-ban létrehozunk egy üres Android projektet az nem fogja támogatni a új Material Design 2.0 könyvtárat.
Annak érdekében, hogy ezen a kisebb problémán túllépjek hozzá kellett adnom néhány függőséget a projekthez és át kellett refaktorálnom AndroidX kompatibilissá.
Ezt nagyon egyszerűen megcsinálhatjuk, ugyanis az Android Studio fejlesztői környezet biztosít egy ilyen menü pontot.
A Google csinált a lépésekről egy kiváló dokumentációt, ami elérhető a \mbox{\url{https://material.io/develop/android/docs/getting-started/}} oldalon.
Ráadásul az oldalon találunk rengeteg hasznos információt a komponensekről és azok használatáról.

\chapter{Az Android applikáció tesztelése}

\section{Unit tesztek}

A Unit teszteket vagy másnéven egységteszteket a programozók írják programozóknak egy bizonyos programozási nyelven.
Arra hivatottak, hogy a szoftver komponenseit izolálják és tesztelhetővé tegyék ismétlődő módon.
A JUnit az elfogadott és alapértelmezett technológia egységtesztek írásához Android platformon.
Egyszerű és nyílt forráskódú keretrendszer a unit tesztek automatizálására.
Eredetileg Eric Gamma és Kent Beck készítette. \cite{android_testing}

\Aref{unit_test}.~kódrészlet jól bemutatja, hogy épül fel egy egységteszt.
Jelen esetben az email cím validására készített függvény tesztelését láthatjuk.

\javaexternal[caption=Unit teszt részlet az email cím validálására.,label=unit_test]{./codes/unit_test.java}

\section{Teljesítmény tesztek}

A teljesítmény tesztelés segít megbízható, reszponzív és jó felhasználói élményt nyújtó alkalmazások elkészítésében.
Ha megfigyeljük a Google Play áruházban néhány nem igazán elterjedt app értékelését, akkor biztosan találunk olyan megjegyzést, ami az adott termék sebességére vonatkozik.
Fontos a felhasználók számára, hogy gyors legyen és hatékony a letöltött szoftver. 
Ellenkező esetben az alkalmazásunk törlésre kerül és lecserélik egy hatékonyabban működő alternatívára.

Az Android alkalmazás teljesítményének tesztelésére az Android Studio beépített profilozó eszközét használtam, amit már \aref{androi_studio} alfejezetben megemlítettem.
Itt csak annyival szeretném kiegészíteni, hogy a hálózati aktivitást is rendkvül kényelmesen tudjuk tesztelni.
Így egy átfogó képet kapunk az alkalmazásban zajló hálózati hívások időtartamáról, típusáról és a háttér szálakról is.
Megtehetjük, hogy kijelölünk egy bizonyos időintervallumot és csak azt vizsgáljuk, ahogy ez \aref{network_performance}.~képen is megfigyelhető.

\begin{figure}[!h]
	\centering
	\includegraphics[width=15cm]{pictures/network_performance}
	\caption{Hálózati kapcsolatok vizsgálása a profilozó segítségével.}
	\label{network_performance}
\end{figure}

\section{Felhasználói tesztek}

A felhasználói tesztek fontos szerepet játszottak abban, hogy megfelelő szoftver születhessen.
Arra használják őket, hogy a termék készítés folyamatában gyors visszajelzést kapjanak a fejlesztők a programmal kapcsolatban.

A célközönségem túlnyomó részének nem idegen a programozás és forráskód látványa, ezért én szakmai szemmel arra voltam kíváncsi, hogy egy informatikában jártas felhasználó hogyan tudja használni az applikációt.
Természetesen én tisztában vagyok az alkalmazás részleteivel és használatával, de nem biztos, hogy mindenki számára érthető a folyamat.
Ebben a szaktársaim óriási segítséget nyújtottak.
Amikor kész lettem egy jelentősebb résszel, mindig odaadtam valakinek, hogy nézze meg mennyire érthető és hogy talál-e benne valamilyen hibát.
Azt kell mondjam, hogy az esetek többségében találtak is.
Egyszerűen nem lehet gondolni minden eshetőségre és felhasználói viselkedésre.
Néha olyan megközelítést is említettek vagy mutattak, amire egyáltalán nem gondoltam volna.
Kétségkívül hozzájárultak az alkalmazás minőségéhez.

\chapter{A visszafordítás teszteléséhez felhasznált programok}\label{teszteles}

\section{Sérülékeny Android alkalmazások}

A teszteléshez keresnem kellett olyan sérülékeny alkalmazásokat, amelyeken jól lehet demonstrálni a visszafejtést/visszafordítást.
Minden alkalmazás, amit itt megemlítek nyílt forráskódú és kimondottan erre a célra készítették őket.
Ez azért is jó, mert a visszafejtett kódot össze lehet hasonlítani az eredetivel és megnézni, hogy mennyire volt hatékony a folyamat.
A jogi következményei egy ilyen visszafordításnak elég ködösek.
Szerettem volna biztosra menni, ezért is választottam nyílt forráskódú, szabadon elérhető alkalmazásokat teszteléshez, mert így érezhetem magam a legnagyobb biztonságban.
A következő lista tartalmazza a teszteléshez felhasznált szándékosan sérülékeny alkalmazásokat.

\begin{enumerate}
	\item
	\begin{description}
		\item[Damn Insecure and Vulnerable Application (Diva)] Talán kicsit régi, mert több mint 3 éve nem volt frissítve. Ettől függetlenül ezzel értem el a legjobb eredményt és ezt találtam a leghasznosabbnak.\newline  Megtalálható itt: \url{https://github.com/payatu/diva-android}.
	\end{description}
	\item
	\begin{description}
		\item [Frida] Ez egy általam fejlesztett alkalmazás, ami kimondottam dinamikus intrumentáció tesztelésére és bemutatására készítettem.\newline Megtalálható itt: \url{https://github.com/t0thkr1s/frida-demo}
	\end{description}
	\item
	\begin{description}
		\item [Purposefully Insecure and Vulnerable Android Application(Pivaa)] A Pivaa egy kicsit modernebb verziója a Diva alkamzasának. Rendkívül sok sérülékenységet tartalmaz, amiből sokat lehet tanulni.\newline Megtalálható itt: \url{https://github.com/HTBridge/pivaa}
	\end{description}
\end{enumerate}

A többi alkalmazást a \url{https://github.com/as0ler/Android-Examples} repository-ból használtam fel, ami nem csak applikációkat tartalmaz, hanem játékokat is.
A forráskód itt nem érhető el, viszont visszafejtés után betekintést nyerhetünk játékok felépítésébe is.

\subsection{Célközönség}

Ezek a sérülékeny alkalmazások több okból jönnek létre és általában a rossz fejlesztői gyakorlatokat mutatják be.
Ilyen programok segítségével tesztelhetjük az elméletben elsajátított tudásunkat.
Gyakran biztonsági tréningek vagy éppen CTF\footnote{Capture The Flag} játékok ürügyén készítenek ilyen szoftvereket.
Kiváló tanulási eszköz lehet az Android alkalmazás fejlesztők, behatolás tesztelők és más érdekeltségi körrel rendelkező személy számára.

\subsection{Sérülénységek}

Ki szeretném emelni és egy kicsit jobban bemutatni a lista első elemét, vagyis a Diva applikációt.
Ezáltal szó fog esni különböző sérülékenységekről is, amelyek Android alkalmazásokat érintenek.
Ezek mind statikus vizsgálattal felfedhetők, nem kell dinamikus analízist alkalmaznunk.
A következő listában szedtem össze néhány fontosabb sérülékenységet.

\begin{enumerate}
	\item
	\begin{description}
		\item[Nem biztonságos logolás] Ez mondjuk pont egy olyan hiba, amit megfigyelhetünk az Android logoló rendszerében, ami a \emph{logcat} elnevezést kapta.
	\end{description}
	\item
	\begin{description}
		\item [Beégetett titkosítási/API kulcsok] Ezek több helyen is előfordulnak, angolul ,,hardcoded strings'-nek hívják. Elég súlyos hibának tekinthető, mivel egyszerűen kiolvasható a visszafejtett forráskódból.
	\end{description}
	\item
	\begin{description}
		\item [Input validálás] Számos helyen találkoztam SQL injektálással. Ez a típusú hiba webes alkalmazásoknál is gyakran előfordul és a nem megfelelő input validálásra alapul.
	\end{description}
\end{enumerate}

\chapter{Megvalósított funkciók}\label{funkciok}

\section{Regisztráció}

A szolgáltatást nem akartam mindenki számára elérhetővé tenni, csak a regisztrált felhasználóknak.
\Aref{registration}.~ábrán látható a regisztrációs felület.
Igazából semmi különösebb mezőt nem tartalmaz, csak a szokásos adatokat kell megadnia annak, aki igénybe szeretné venni a szolgáltatást.
Ha a regisztráció sikeresen befejeződött, akkor vissza irányítom a felhasználót a bejelentkezési felületre.
A folyamatot próbáltam minél egyszerűbbre és magától értetődőre tervezni.

A mezőket tekintve \texttt{TextInputLayout}-ba ágyazott \texttt{TextInputEditText}-et használtam.
A \texttt{TextInputLayout} rendelkezik, olyan tulajdonságokkal, mint például a segítséget nyújtó szöveg és az animáció.
Ez által még nyilvánvalóbb, hogy melyik mezőbe mit kell írni.

Számításba vettem, hogy a felhasználó nem biztos, hogy álló helyzetben fogja tartani a telefonját, ezért külön layout fájlokat készítettem a fekvő nézethez.
Szerencsére nem kellet minden felülethez külön fekvő nézetet késztenem, csak a regisztrációhoz és a bejelentkezéshez.

\section{Bejelentkezés}

Természetesen regisztrálás után a felhasználónak be kell jelentkeznie, hogy hozzáférhessen azokhoz a végpontokhoz, amik bejelentkezéshez vannak kötve.
Lényegében az összes lényeges végpont bejelentkezéshez van kötve, ezért mondhatjuk, hogy a bejelentkezést kötelező megtenni.

A felület itt csak két mezőt tartalmaz, a felhasználó nevet és a jelszót.
Mivel ez egy folyamatban lévő fejlesztés nem tartottam prioritásnak a jelszó visszaállítás funkció implementálását, ebben a korai verzióban.
A jelszó mezőben bekapcsoltam egy úgynevezett jelszó kapcsolót, ami a mező jobb szélén látható.
Segítségével a felhasználók láthatóvá tehetik a beírt jelszavukat és ellenőrizhetik annak helyességét.

Alapvetően a \texttt{MainActivity} indul az alkalmazás futtatásakor és az \texttt{AuthenticationActivity} csak akkor indul, ha nincsen mentett felhasználónév és jelszó páros.
Az \texttt{AuthenticationActivity} tartalmazza mind a bejelentkezési, mind a regisztrációs fragment komponenst.

\begin{figure}[!h]
	\centering
	\includegraphics[height=15cm]{pictures/android_login_registration}
	\caption{A bejelentkezési és regisztrációs felület megvalósítása.}
	\label{registration}
\end{figure}

\section{Kijelentkezés}

Szerver oldalon csak az \texttt{Authorization Header} van ellenőrizve, ami azt jelenti, hogy minden egyes hálózati kérésben benne kell lennie.
Ennek a kezelését úgy oldottam meg, hogy sikeres bejentkezés után \texttt{SharedPreferences} használatával eltároltam a felhasználónevet és a jelszót.
Amíg nem történik kijelentkezés, addig ezek az adatok mentve maradnak.

\Aref{saving_sharedpref}.~kódrészleten láthatjuk, hogyan történik az adatok mentése.
A \texttt{SharedPreferences} segítségével kulcs-érték párokat tárolhatunk biztonségos módon.
A \texttt{getSharedPreferences()} metódus 2 paramétert vár, az egyik a név, a másik a használni kívánt mód. 
Névnek az alkalmazás csomag nevét választottam és privát módban hoztam létre, hogy csak az én alkalmazásom férhessen hozzá az adatokhoz.

\javaexternal[caption=Adatok mentése \texttt{SharedPreferences} segítségével.,label=saving_sharedpref]{./codes/saving_sharedpref.java}

\Aref{deleting_sharedprefs}.~kódrészletben láthatód metódus nem sok eltérést mutat, viszont elengedhetetlen volt ahhoz, hogy töröljem az összes \texttt{SharedPreferences}~-be mentett adatot.

\javaexternal[caption=Az összes mentett adat törlése.,label=deleting_sharedprefs]{./codes/deleting_sharedprefs.java}

\section{Adatok törlése}

A kliens oldalon elég sok adat jelenik meg, ami természetesen tárolva van.
Ilyen például a feltöltések listája, értesítések és a letöltött fájlok is ide tartoznak.
Az adatok törlése funkcióval biztosítottam, hogy a felhasználónak lehetősége legyen törölni minden adatot és előzményt.
Ide tartozik a gyorsítótárba másolt feltöltött alkalmazások, amik egy idő után értékes tárhelyet foglalhatnak el.
Nem beszélve arról, hogy az adatbázisban lévő összes tábla adatát ürítem.
Lehetséges, hogy kényelmesebb lett volna, ha a felhasználó maga választja ki mit szeretne törölni.
Sajnos ez a korai verzió csak az együttes törlést biztosítja.
Jól jöhet ez a funkció akkor is ha a telefon esetleg nem rendelkezik elég tárhellyel vagy egyszerűen csak helyet szeretnénk felszabadítani.

\section{Fájl feltöltés}

Az alkalmazás egy alapvető funkciója, hogy fel tudjuk tölteni az APK fájlokat.
Ezt a funkciót próbáltam a legkézenfekvőbb helyen elhelyezni, mert ezzel indul az egész folyamat és magától értetődőnek kell lennie.
Ezért lett a legeleső fragment a feltöltések listáját tartalmazó fragment.
Ebben a feltöltési listában jelenítem meg a feltöltött APK fájlok neveit és a feltöltés dátumát.

A feltöltéshez a felhasználónak egy jól látható \texttt{FloatingActionButton} komponensre kell kattintania.
A tervezési szakaszban úgy gondoltam, hogy hasznos lenne egy saját fájl kiválasztó felületet készíteni.
Nem sokkal ezután rájöttem, hogy teljesen felesleges újra feltalálni azt, amire már van működő megoldás és nem kellene haszontalan felületekkel bonyolítani az applikációt.
Biztos találkoztunk már olyan app-al, ami elindított egy külső alkalmazást csak azért, hogy elvégezzel valamilyen feladatot.
Én is egy ilyen megoldásra hagyatkoztam.
Nem csak \emph{Activity}-ket tudunk indítani \emph{Intent}-ek segítségével, hanem különböző műveleteket is elvégezhetünk.
Az ilyen \emph{Intent}-eket \emph{Implicit Intent}-eknek nevezzük.
Példának okáért, a fájl kiválasztás egy ilyen művelet.
\emph{Implicit intent} használatával indítottam el a fájl kiválasztást, aminek többek között megadtam, hogy milyen típusú fájlokat szeretnék kiválasztani.
Ez a típus természetesen a \texttt{application/vnd.android.package-archive} volt, ami megfelel az Android telepítő fájloknak.
Ebben az esetben nincs lehetőségünk más típusú fájlt kiválasztani csak a megadottat.

A fájl kiválasztása után az \texttt{onActivityResult} metódus \emph{Intent} típusú paraméterében kapjuk meg az URI\footnote{Uniform Resource Identifier}-t.
Ezt az URI-t felhasználva elmentettem a fájlt az alkalmazás gyorsítótárába.
Erre azért volt szükség, mert különben nem kaptam volna meg az abszolút elérési útvonalat.
Eztán már csak service elindítása maradt hátra. 

A \texttt{startService(Intent service)} metódus egy \emph{Intent}-et vár, ami segítségével elindíthatjuk a háttér service-t.
Fontos, hogy ez még így nem elég, hanem extraként hozzá kell adni a feltölteni kívánt fájlt.
\Aref{uploads_notifications}.~ábra bal oldali képernyőképén látható a feltöltött fájlok listája.

Miután kiválasztottuk a fájlt és sikeresen megkaptuk az abszolút elérési útvonalát elindítom a feltöltési háttér service-t.
Nem akartam túl sok kódot bemutatni, de úgy gondolom, hogy talán \aref{okhttp_example}.~kódrészlet a legfontosabb a hálózati kommunikációt tekintve.
Láthatjuk, hogy a szükséges típusokat Builder tervezési minta segítségével hozhatjuk létre.
Némileg kikommenteztem a kódot, hogy jobban értelmezhessük annak felépítését.
Először a \texttt{RequestBody}-t építettem fel.
Típusként megadtam, hogy \texttt{form}-ot szeretnék küldeni, majd megadtam a kulcsot, magát a fájl nevét és a egy \texttt{RequestBody}-t.
Ez utóbbit a \texttt{RequestBody.create()} segítségével készítettem, ami vár paraméterként egy média típust és magát a fájlt.

A \texttt{HttpUrl} résznél is felhasználtam a tervezési minta adta modularitást.
Külön adtam meg a sémát, protokolt, host nevet és port számot.
Az \texttt{addDataPathSegment()} metódus használatával megtudjuk adni a pontos elérési utat paraméterként.
Ezután a \texttt{Request} felépítése következett. 
URL-ként a előbb felépített \texttt{httpUrl} példányt adtam át, valamint szükséges megadnunk az \texttt{Authorization Header}-t, mert a szerver ezzel ellőrzni, hogy valóban regisztrált felhasználók vagyunk.
Végül, a \texttt{post()} metódusnak átadtam a \texttt{formBody} példányt és ezzel minden elő lett készítve a hívás elküldéséhez.
A \texttt{okHttpClient.newCall(request).enqueue()} metódus egy úgynevezett \texttt{Callback} interfészt vár.
Ennek van két metódusa a \texttt{onFailure} és \texttt{onResponse}.
Az előbbi akkor hívódik meg, ha hálózati vagy bármi egyéb hiba lépett fel a hívás közben.
Az utóbbi akkor, ha sikeres HTTP válasz érkezett a szervertől.
Itt nagyon fontos megemlíteni, hogy ez a hívás egy háttér szálon fut.
Így nem akadályozzuk a UI szálat és jó felhasználói élményt tudunk nyújtani.
Gondolnunk kell azonban arra, hogy ha valami frissíteni szeretnénk a felhasználói felületen, akkor azt a UI szálon kell megtennünk.
Hasonlóan építettem fel a többi hálózati kérést is az alkalmazásomban, ezért tartottam fontosnak az \texttt{OkHttp} könyvtár lehetőségeit bemutatni.

\javaexternal[caption=APK fájl feltöltése OkHttp segítségével.,label=okhttp_example]{./codes/okhttp.java}

\section{Fájl letöltés}

A fájl letöltés is egy roppant fontos funkció, ugyanis csak így jut el a felhasználóhoz az elkészült projekt.
A megvalósítását hozzákötöttem az értesítésekhez, mert a kliens abban kapja vissza a letöltendő fájl nevét.
Megfigyelhetjük \aref{uploads_notifications}.~ábra jobb oldali képernyőképén, hogy minden egyes értesítés kártyáján ott a letöltés gomb.
Ha ezekre rákattintunk, akkor itt is minden egyes alkalommal egy újabb háttér service fog elindulni.

Azt is megtehetjük, hogy akár többször is letöltjük ugyanazt a fájlt.
Ha már lokálisan létezik egy ugyanolyan nevű projekt, mint amit éppen letöltünk akkor sem kell félnünk, hogy felül írjuk, mert egyedi nevet fog kapni.
Ezt úgy valósítottam meg, hogy ha létezik már a projekt mappája, akkor hozzáfőzök egy számot és 0-tól kezdődően mindig növelem.

\begin{figure}[!h]
	\centering
	\includegraphics[height=15cm]{pictures/android_uploads_notifications}
	\caption{A feltöltött APK fájlok és értesítések felülete.}
	\label{uploads_notifications}
\end{figure}

\section{Navigáció a fájlrendszerben}

A letöltött és kitömörített projektek az alkalmazás mappájában kerülnek.
Ennek a mappának a neve megegyezik az alkalmazás nevével és az elsődleges külső tárhelyen foglal helyet.
Ezzel alapvetően nincs is semmi probléma, csak ha megszeretnénk nézni a fájlokat, akkor el kellene hagynunk az alkalmazást.
Ez pedig rossz felhasználói élményhez vezetett volna.
Ennek megoldására megvalósítottam egy nagyon egyszerű fájl rendszer navigációt, de ezt csak az alkalmazás mappájában tettem lehetővé.
Szóval a felhasználó nem tud a fájlrendszerben feljebb navigálni, csak a ,,Reverse Droid'' gyökér mappáig.
Ezzel a funkcióval kitömörítés után egyszerűen és gyorsan elérhetővé válik a projekt a felhasználó számára.
A mappák esetében megjelenítettem a módosítás dátumát és hogy hány fájlt/mappát tartlmaz.
A fájlok részleteit tekintve a fájl nevét, módosítás dátumát és a fájl méretét is feltüntettem.
Továbbá hozzáadtam egy olyan funkciót, hogy ha hosszan kattintunk egy mappán, akkor lehetőséget kapunk annak törlésére.
Ha nem egy mappán kattintunk hosszan, hanem egy fájlon, akkor három opció közül is választhatunk.
Az első triviális funkció itt is a fájl törlése volt, a második a fájl megosztása kompatibilis külső alkalmazással.

Végül, de nem utolsó sorban a kód megtekintése menü pont kapott helyet.
Ennek a működéséről és megvalósításáról már említést tettem a \nameref{code_view} alfejezetben, de nem említettem meg minden részletet.
Kimaradt példul az, hogy csak bizonyos fájlkiterjesztéseket támogatok jelen helyzetben.
Mivel a forráskód tartalmazza az igazán érdekes dolgokat, ezért arra koncetráltam, hogy legalább az Android projektekre jellemző szöveges fájlkiterjesztéseket támogassam.
A különböző képek és speciális fájlok megjelenítése egyenlőre nincsen támogatva, de ez is egy olyan funkció, amit megszeretnék valósítani a jövőre nézve.
A támogatott kiterjesztéseket jelenleg az is befolyásolja, hogy maga a \emph{CodeView} miket támogat.

A visszalépés megvalósítása okozott egy kisebb fejtörést.
A vissza gomb megnyomására túlságosan is bonyodalmas lett volna megvalóstani a visszalépést, ezért úgy döntöttem, hogy egy külön elemmel fogom ezt kivitelezni.
Ez az elem úgymond egy speciális lista elem, amit akkor jelenítek meg ha nem az alkalmazás mappájában tartózkodunk.
Emlékeim szerint több fájl kezelő is használta már ezt a megoldást és elég hatékonynak tűnt ez a fajta visszalépési technika.

\section{Értesítések}\label{ertesitesek}

Az értesítések küldése és fogadása szintén egy kulcsfontosságú része az alkalmazásnak, ezt már többször is hangsúlyoztam.
A fájlok letöltése és kitömörítése mérettől, valamint hálózati kapcsolattól függően időt vesz igénybe.
Az elején úgy gondoltam, hogy egy egyszerű \emph{Toast} üzenet is elég a feltöltés állapotának visszajelzésére.
Aztán hamar rá kellett jönnöm, hogy ez nem ad elég információt a felhasználó számára, ráadásul rossz felhasználói élményhez is vezet.
Végül úgy döntöttem, hogy feltöltést is hasonlóan valósítom meg, mint a letöltést.

\Aref{notifications}.~ábrán láthatóak az alkalmazásban használt értesítések.
Ez a három értesítés jól érzékelteti a három fő funkcióját az applikációnak.
Ezeket össze is foglaltam a következő listában:

\begin{enumerate}
	\item Android telepítő fájl feltöltése
	\item Értesítés a projekt készenlétéről
	\item Az elkészült tömörített projekt letöltése
\end{enumerate}

A megvalósítást illetően az első és a harmadik funkció megvalósítása kliens oldalon történt teljes egészében.
A harmadik természetesen a szerverről érkezik, ha befejeződött a fájl feldolgozása.
Ezek mind az adott körülményektől függenek és azzal is számolni kell, hogy jelentős időtartamot igényelnek.
Azt is lehetővé szerettem volna tenni a felhasználó részére, hogy a műveletek között is elhagyhassa az applikációt.

Itt is a háttér service volt az az applikáció komponens, amit ennek kivitelezésére felhasználtam.
Segítségével hosszabb ideig tartó műveleteket tudunk végezni, anélkül hogy a felhasználó interakcióba lépne az applikációval.

\begin{figure}[!h]
	\centering
	\includegraphics[height=10cm]{pictures/notifications}
	\caption{Az alkalmazásban megjelenő értesítések.}
	\label{notifications}
\end{figure}

\chapter{Továbbfejlesztési lehetőségek}\label{lehetosegek}

Úgy gondolom, hogy sokkal nagyobb piaci érték rejlik ebben az alkalmazásban, mint amennyit egyedül sikerült megvalósítanom.
A jövőben is szeretném folytatni a fejlesztést és esetlegesen nyílt forráskódúvá tenni a projekteket, hogy mások is közre tudjanak működni a fejlesztésben.

Szeretnék több figyelmet fordítani a biztonságra és hatékonyságra. 
Gondolok itt a biztonságos kommunikációra TLS-es keresztül és a harmadik féltől származó könyvtárak csökkentésére.
Azért lenne érdemes minimalizálni a harmadik féltől származó könyvtárakat, mert nem mindig tudjuk milyen kódot tartalmaznak és mennyire tartják karban a kód bázist.

Jelenleg csak a forráskódok megjelentését támogatja az alkalmazás, de jó lenne ha különböző fájl típusokat is megtudna jeleníteni.
Például a képek vagy adatbázisok megtekintése is kritikus lehet egy Android alkalmazás elemzésekor.
A kód visszafejtése végén egy összegző report is hasznos lehetne a felhasználó számára, ami tartalmazná a feldolgozott fájlok számát és egy gyors áttekintést nyújtana az adott alkalmazással kapcsolatban.

Egy forráskód elemző integrálása is jelentős előnnyel járhat a többi alkalmazással szemben. Hasonlóan a Google Play Protect-hez, jelezhetnénk a felhasználó számára, ha a feltöltött \emph{apk} malware.
Találkoztam több webes \emph{apk} analizálóval, ahol csak az Android komponenseket emelték ki, de az elemzést már a felhasználóra bízták.
Nyilván nem lenne célszerű mindent egy algoritmusra bízni, de mindenesetre könnyebbséget látok egy átfogó analízisben, ami esetlegesen mesterséges intelligenciára alapul.

\chapter{Tapasztalatok}\label{tapasztalatok}

Úgy érzem elértem a célom ezzel a projekttel és sokat sikerült tanulnom az elkészítése alatt.
Új technológiákat ismertem meg és használtam.
Nem állítom, hogy nincs rajta javítani való, hiszen ez mégis csak egy szoftver, amit folyamatosan karban kell tartani és fejleszteni.
A fejlesztés minden fázisában találtam valami kihívást, ami segítette a fejlődésemet és arra ösztönzött, hogy jobban megismerjem az adott technológiát.

Természetesen nem volt minden magától értetődő és jó pár nehézséggel is találkoztam, amiket már korábban meg is említettem.
Számomra, ha valami nem sikerült az mindig ösztönzőleg hatott és motivált a tanulásban.
Sikerült az idegen technológiák iránt érzett kíváncsiságom is kielégíteni.
A ,,reverse engineering'' világába is betekintést nyertem, ami különösen érdekelt engem. 

A fejlesztésnél csak egyetlen kellemetlen dologgal találkoztam. Szerintem sok fejlesztő egyet ért ha azt mondom, hogy a hiányos vagy éppen félre vezető dokumentáció a legnagyobb ellensége.
Szerencsére nem sokszor futottam bele, de amikor igen, akkor pár napig álltam a fejlesztéssel. Végül az oldalon egy rendkívül türelmes és segítőkész fiatalember segített a helyes irányba. 

Még a problémáival együtt is úgy gondolom, hogy sikerült egy olyan szoftvert készítenem, ami egyedi és megállja a helyét a piacon. 

\begin{thebibliography}{1}
	\bibitem{git} \textsc{Somasundaram R.} Git: Version control for everyone. Packt Publishing Ltd; 2013.
	\smallskip
	\bibitem{flask} \textsc{Grinberg M.} Flask web development: developing web applications with python. O'Reilly Media, Inc.; 2018 Március 5.
	\smallskip
	\bibitem{sqlite} \textsc{Kreibich J.} Using SQLite. O'Reilly Media, Inc.; 2010 Augusztus 17.
	\smallskip
	\bibitem{docker} \textsc{Turnbull J.} The Docker Book: Containerization is the new virtualization. James Turnbull; 2014 Július 14.
	\smallskip
	\bibitem{android_testing} \textsc{Diego Torres}: Android application testing guide. Packt Publishing Ltd; 2011. Június 23.
	\smallskip
	\bibitem{json1} \textsc{Bassett L.} Introduction to JavaScript Object Notation: A to-the-point Guide to JSON. O'Reilly Media, Inc.; 2015 Augusztus 5.
	\smallskip
	\bibitem{continuous_integration} \textsc{Fowler M, Foemmel M.} Continuous integration. Thought-Works; 2006 Május 1. \url{http://www.dccia.ua.es/dccia/inf/asignaturas/MADS/2013-14/lecturas/10_Fowler_Continuous_Integration.pdf}
	\smallskip
	\bibitem{json2} \textsc{ONLINE: Crockford, Douglas} Introducing JSON. \url{https://www.json.org/}; 2009 Május 28.
	\smallskip
	\bibitem{statista} \textsc{ONLINE}: Number of mobile phone users worldwide from 2015 to 2020 \url{https://www.statista.com/statistics/274774/forecast-of-mobile-phone-users-worldwide}
	\smallskip
	\bibitem{androidstudio} \textsc{ONLINE}: Everything you need to build on Android \url{https://developer.android.com/studio/features.html}
	\smallskip
	\bibitem{espresso} \textsc{ONLINE}: Create UI tests with Espresso Test Recorder \url{https://developer.android.com/studio/test/espresso-test-recorder}
	\smallskip
	\bibitem{pycharm} \textsc{ONLINE}: PyCharm Features \url{https://www.jetbrains.com/pycharm/features}
	\smallskip
	\bibitem{androidx} \textsc{ONLINE}: AndroidX Overview \url{https://developer.android.com/jetpack/androidx}
	\smallskip
	\bibitem{room} \textsc{ONLINE} Save data in a local database using Room \url{https://developer.android.com/training/data-storage/room/index.html}
	\smallskip
\end{thebibliography}

\end{document}
